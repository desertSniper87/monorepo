<html>
<head><title>Reverse Engineered KeePass (KDBX) File Format</title></head>
<body>
<h1>Reverse Engineered KeePass (KDBX) File Format</h1>

<hr/>

<p>
Integers are stored in little endian format.<p>
<p>
<h2>*Magic bytes</h2>
<p>
8 bytes:<p>
0x03, 0xd9, 0xa2, 0x9a, 0x67, 0xfb, 0x4b, 0xb5<p>
<p>
The magic bytes are used as a first check to determine if a file could be a KDBX file.<p>
<p>
<h2>*Format version</h2>
<p>
This field is uint32, where the upper 16 bits represent the major version, and the lower 16 bits represent the minor version.<p>
<p>
Version 2.20.1: 0x003001<p>
<p>
<h2>*Header</h2>
<p>
The header consists of a number of header fields. The order of the fields is not important. Header fields are read until the end of header field is encountered. A header field starts with a header with the following structure:<p>
<p>
uint8	id<p>
uint16	size of field data<p>
<p>
followed by the field data.<p>
<p>
Header fields<p>
<p>
end of header<p>

<hr/>

<ul>
<li>
id	0<p>
size	4<p>
data	0x0d, 0x0a, 0x0d, 0x0a<p>
<p>
</li>
<li>
comment<p>
<p>
id	1<p>
<p>
The comment field seems to be ignored in KeePass.<p>
<p>
</li>
<li>
cipher id<p>
<p>
id	2<p>
<p>
The cipher id is 16 bytes. For AES-CBC with PKCS7 padding, which is the default cipher, the id is<p>
0x31,0xc1,0xf2,0xe6,0xbf,0x71,0x43,0x50,0xbe,0x58,0x05,0x21,0x6a,0xfc,0x5a,0xff<p>
<p>
</li>
<li>
compression<p>
<p>
id	3<p>
size	4<p>
data    0x00,0x00,0x00,0x00 (no compression)<p>
<p>
</li>
<li>
master seed<p>
<p>
id	4<p>
size	32<p>
<p>
The master seed is a 32 byte salt value for the key transformation.<p>
<p>
</li>
<li>
transform seed<p>
<p>
id	5<p>
size	KeePass writes 32 bytes of transform seed, but accepts a seed of any length when reading a file.<p>
<p>
The transform seed is another salt value for the key transformation.<p>
<p>
</li>
<li>
number of transform rounds<p>
<p>
id	6<p>
size	8<p>
<p>
The number of key transformation rounds, expressed as an uint64.<p>
<p>
</li>
<li>
iv<p>
<p>
id	7<p>
size	KeePass always writes 16 bytes of IV, but the length is not checked when reading the file.<p>
        Having the wrong IV length would cause an exception in the encryption engine, though.<p>
<p>
The IV of the cipher.<p>
<p>
</li>
<li>
protected stream key<p>
<p>
id	8<p>
size	KeePass always writes 32 bytes, but length is not checked when reading the file.<p>
<p>
the protected stream key seems to be a way to obfuscate some fields of the decrypted file.<p>
<p>
</li>
<li>
stream start bytes<p>
<p>
id	9<p>
size	32<p>
<p>
the initial 32 bytes of the decrypted stream, used to verify that the decryption key is<p>
probably correct before decrypting the entire stream<p>
<p>
</li>
<li>
inner random stream id<p>
<p>
id	10<p>
size	4<p>
<p>
an uint32 giving the algorithm used to produce the random stream used with the protected stream key for obfuscation<p>
<p>
</li>
</ul>

</body>
</html>
